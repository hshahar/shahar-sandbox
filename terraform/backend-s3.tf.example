# S3 Backend Configuration for Terraform State
# 
# This file demonstrates how to configure Terraform to store state in AWS S3
# with DynamoDB locking for team collaboration and state protection.
#
# SETUP INSTRUCTIONS:
# 1. Create S3 bucket and DynamoDB table (see setup commands below)
# 2. Rename this file to backend.tf (remove .example extension)
# 3. Update the configuration values for your environment
# 4. Run: terraform init -migrate-state
# 5. Confirm migration when prompted
#
# WARNING: Do NOT commit AWS credentials to version control!

terraform {
  backend "s3" {
    # S3 Bucket Configuration
    bucket = "sha-k8s-terraform-state"           # Change to your bucket name
    key    = "dev/terraform.tfstate"              # Path within bucket (environment-specific)
    region = "us-east-1"                          # Change to your AWS region
    
    # State Locking with DynamoDB
    dynamodb_table = "sha-k8s-terraform-locks"   # Change to your table name
    
    # Encryption
    encrypt = true                                 # Encrypt state at rest
    
    # Optional: Server-Side Encryption with KMS
    # kms_key_id = "arn:aws:kms:us-east-1:ACCOUNT_ID:key/KEY_ID"
    
    # Optional: AWS Profile (if using multiple AWS accounts)
    # profile = "default"
    
    # Optional: Role ARN for assuming a role
    # role_arn = "arn:aws:iam::ACCOUNT_ID:role/TerraformStateRole"
    
    # Optional: Workspace key prefix (for terraform workspaces)
    # workspace_key_prefix = "workspaces"
  }
}

# ============================================================================
# AWS SETUP COMMANDS
# ============================================================================
# Run these commands to create the required AWS resources:
#
# 1. CREATE S3 BUCKET:
# aws s3api create-bucket \
#   --bucket sha-k8s-terraform-state \
#   --region us-east-1
#
# For regions other than us-east-1, add location constraint:
# aws s3api create-bucket \
#   --bucket sha-k8s-terraform-state \
#   --region us-west-2 \
#   --create-bucket-configuration LocationConstraint=us-west-2
#
# 2. ENABLE VERSIONING (Important for state recovery):
# aws s3api put-bucket-versioning \
#   --bucket sha-k8s-terraform-state \
#   --versioning-configuration Status=Enabled
#
# 3. ENABLE SERVER-SIDE ENCRYPTION:
# aws s3api put-bucket-encryption \
#   --bucket sha-k8s-terraform-state \
#   --server-side-encryption-configuration '{
#     "Rules": [{
#       "ApplyServerSideEncryptionByDefault": {
#         "SSEAlgorithm": "AES256"
#       }
#     }]
#   }'
#
# 4. BLOCK PUBLIC ACCESS (Security best practice):
# aws s3api put-public-access-block \
#   --bucket sha-k8s-terraform-state \
#   --public-access-block-configuration \
#     BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true
#
# 5. CREATE DYNAMODB TABLE FOR LOCKING:
# aws dynamodb create-table \
#   --table-name sha-k8s-terraform-locks \
#   --attribute-definitions AttributeName=LockID,AttributeType=S \
#   --key-schema AttributeName=LockID,KeyType=HASH \
#   --billing-mode PAY_PER_REQUEST \
#   --region us-east-1
#
# 6. ENABLE POINT-IN-TIME RECOVERY (Optional, recommended):
# aws dynamodb update-continuous-backups \
#   --table-name sha-k8s-terraform-locks \
#   --point-in-time-recovery-specification PointInTimeRecoveryEnabled=true
#
# ============================================================================

# ============================================================================
# ENVIRONMENT-SPECIFIC CONFIGURATIONS
# ============================================================================
# For multiple environments (dev, staging, prod), use different state files:
#
# Dev:     key = "dev/terraform.tfstate"
# Staging: key = "staging/terraform.tfstate"
# Prod:    key = "prod/terraform.tfstate"
#
# Or use Terraform workspaces:
# terraform workspace new dev
# terraform workspace new staging
# terraform workspace new prod
# ============================================================================

# ============================================================================
# MIGRATION FROM LOCAL STATE
# ============================================================================
# To migrate existing local state to S3:
#
# 1. Ensure you have a backup of terraform.tfstate:
#    cp terraform.tfstate terraform.tfstate.backup
#
# 2. Configure backend (rename this file to backend.tf)
#
# 3. Initialize with migration:
#    terraform init -migrate-state
#
# 4. Verify migration:
#    terraform state list
#    aws s3 ls s3://sha-k8s-terraform-state/dev/
#
# 5. Confirm local state is backed up, then remove:
#    # Keep backup safe before deleting!
#    # rm terraform.tfstate terraform.tfstate.backup
# ============================================================================

# ============================================================================
# IAM POLICY FOR TERRAFORM USER
# ============================================================================
# Minimal IAM policy for Terraform to access S3 backend:
#
# {
#   "Version": "2012-10-17",
#   "Statement": [
#     {
#       "Effect": "Allow",
#       "Action": [
#         "s3:ListBucket",
#         "s3:GetBucketVersioning"
#       ],
#       "Resource": "arn:aws:s3:::sha-k8s-terraform-state"
#     },
#     {
#       "Effect": "Allow",
#       "Action": [
#         "s3:GetObject",
#         "s3:PutObject",
#         "s3:DeleteObject"
#       ],
#       "Resource": "arn:aws:s3:::sha-k8s-terraform-state/*"
#     },
#     {
#       "Effect": "Allow",
#       "Action": [
#         "dynamodb:GetItem",
#         "dynamodb:PutItem",
#         "dynamodb:DeleteItem"
#       ],
#       "Resource": "arn:aws:dynamodb:us-east-1:ACCOUNT_ID:table/sha-k8s-terraform-locks"
#     }
#   ]
# }
# ============================================================================

# ============================================================================
# TROUBLESHOOTING
# ============================================================================
#
# ERROR: "Error acquiring the state lock"
# SOLUTION: Check DynamoDB table for stale locks and remove if necessary:
#   aws dynamodb scan --table-name sha-k8s-terraform-locks
#   # If you see a stale lock, force unlock:
#   terraform force-unlock LOCK_ID
#
# ERROR: "Access Denied" on S3
# SOLUTION: Verify IAM permissions and AWS credentials:
#   aws sts get-caller-identity
#   aws s3 ls s3://sha-k8s-terraform-state/
#
# ERROR: "NoSuchBucket"
# SOLUTION: Create the S3 bucket first (see setup commands above)
#
# ERROR: "ResourceNotFoundException" on DynamoDB
# SOLUTION: Create the DynamoDB table first (see setup commands above)
#
# ============================================================================

# ============================================================================
# ALTERNATIVE: AZURE BACKEND
# ============================================================================
# If using Azure instead of AWS:
#
# terraform {
#   backend "azurerm" {
#     resource_group_name  = "sha-k8s-terraform-state"
#     storage_account_name = "shak8sterraformstate"
#     container_name       = "tfstate"
#     key                  = "dev.terraform.tfstate"
#   }
# }
#
# Setup commands:
# az group create --name sha-k8s-terraform-state --location eastus
# az storage account create --name shak8sterraformstate --resource-group sha-k8s-terraform-state --location eastus --sku Standard_LRS
# az storage container create --name tfstate --account-name shak8sterraformstate
# ============================================================================

# ============================================================================
# ALTERNATIVE: GCS BACKEND (Google Cloud Storage)
# ============================================================================
# If using Google Cloud instead of AWS:
#
# terraform {
#   backend "gcs" {
#     bucket  = "sha-k8s-terraform-state"
#     prefix  = "dev"
#   }
# }
#
# Setup commands:
# gsutil mb -p PROJECT_ID -l US gs://sha-k8s-terraform-state
# gsutil versioning set on gs://sha-k8s-terraform-state
# ============================================================================

# ============================================================================
# BEST PRACTICES
# ============================================================================
# 1. Enable S3 versioning for state recovery
# 2. Use DynamoDB locking to prevent concurrent modifications
# 3. Enable encryption at rest (encrypt = true)
# 4. Use separate state files per environment
# 5. Never commit AWS credentials to Git
# 6. Use IAM roles instead of access keys when possible
# 7. Regularly test state recovery procedures
# 8. Monitor S3 bucket for unauthorized access
# 9. Set up S3 lifecycle policies to archive old versions
# 10. Document your backend configuration in README
# ============================================================================
